## 组件

> 组件是抽象的独立功能模块，react 应用程序由组建构建而成。

### 组件的两种形式

1. function 组件

   > 函数组件通常 无状态，仅关注内容展示，返回渲染结果即可

2. class 组件

   > class 组件通常拥有状态和生命周期，继承于 Component，实现 render 方法，创建 component/CompType.js 提取前面 jsx 相关代码至 component/JsxTest.js

### 组件状态管理

如果组件中的数据会变化，并影响页面内容，则组件需要拥有状态（state），并维护状态。

#### 类组件中的状态管理

class 组件使用 state 和 setState 维护状态
范例：创建状态管理组件 components/StateMgt.js

```jsx
import React, { Component } from 'react'

class Clock extends Component {
  constructor(props) {
    super(props)
    // 初始化状态
    this.state = {
      date: new Date()
    }
  }

  componentDidMount() {
    // 定时器
    this.timerId = setInterval(() => {
      // 通过setState更新状态
      this.setState({
        date: new Date()
      })
    }, 1000)
  }

  componentWillUnmount() {
    clearInterval(this.timerId)
  }

  render() {
    return <div>{this.state.date.toLocaleTimeString()}</div>
  }
}

export default function StateMgt() {
  return (
    <div>
      <Clock></Clock>
    </div>
  )
}
```

拓展：setState 特性讨论

- 用 setState 更新状态而不能直接修改
  `this.state.counter += 1 // 错误的`
- setState 是批量执行的，因此对同一个状态执行多次只起一次作用，多个状态的更新可以放在同一个 setState 中进行：

```jsx
componentDidMount() {
  // 假如counter初始值为0，执行三次以后其结果是多少
  // 若同一个key多次出现，最后那个起作用
  this.setState({counter: this.state + 1})
  this.setState({counter: this.state + 1})
  this.setState({counter: this.state + 1})
}
```

- setState 通常是异步的，因此如果需要获取到最新状态值有以下是三种方式：

  1. 传递函数给 setState 方法，

  ```js
  this.setState((state, props) => ({ counter: state.counter + 1 })) // 1
  this.setState((state, props) => ({ counter: state.counter + 1 })) // 2
  this.setState((state, props) => ({ counter: state.counter + 1 })) // 3
  ```

  2. 使用定时器

  ```js
  setTimeout(() => {
    console.log(this.state.counter)
  }, 0)
  ```

  3. 原生实践中修改状态

  ```js
  componentDidMount () {
    document.body.addEventListener('click', this.changeValue, false)
    changeValue () {
      this.setState({counter:this.state.counter + 1})
      console.log(this.state.counter)
    }
  }
  ```

### 事件处理

```jsx
/**
 * 用户事件处理
 */
import React, { Component } from 'react'

export default class EventHandle extends Component() {
  constructor(props) {
    super(props)
    this.state = {
      name: ''
    }
    // 1. 在constructor里重新绑定this
    // this.handleChange = this.handleChange.bind(this)
  }

  handleChange(e) {
    // this 指向
    this.setState({
      name: e.target.value
    })
  }

  // 3. 使用箭头函数(推荐使用)
  // handleChange = e => {
  //   this.setState({
  //     name: e.target.value
  //   })
  // }

  render() {
    return (
      <div>
        {/* 2. 使用箭头函数传参的方式 */}
        <input
          type='text'
          value={this.state.name}
          onChange={e => this.handleChange(e)}
        />
        <p>{this.state.name}</p>
      </div>
    )
  }
}
```

### 组件通信

#### Props 属性传递

```jsx
// index.js
ReactDOM.render(<App title='react真帅' />, document.getElementById('root'))

// App.js
{
  this.props.title
}
```

如果父组件传递的是函数，则可以把子组件信息传入父组件，这个常被称为状态提升。StateMgt.js

```jsx
// StateMgt
<Clock change={this.onChange}>

// clock
this.timerID = setInterval(() => {
  this.setState({
    date: new Date()
  }, () => {
    // 每次状态更新就通知父组件
    this.props.change(this.state.date)
  })
}, 1000)
```

#### context

跨层级组件之间通信

> 主要用于组件库开发中

#### redux

类似 vuex，无明显关系的组件间通信
